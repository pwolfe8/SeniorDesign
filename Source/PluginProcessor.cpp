/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

BOOL Plugin2AudioProcessor::ModifyCommSettings(HANDLE hComPort)
{
	//COMMTIMEOUTS ctos;
	DCB PortDCB;
	// Initialize the DCBlength member.
	PortDCB.DCBlength = sizeof(DCB);
	// Get the default serial port settings DCB information.
	GetCommState(hSerial, &PortDCB);
	// Change the common DCB structure settings to modify serial port settings.
	PortDCB.BaudRate = 9600;              // Current baud
	PortDCB.fBinary = TRUE;               // Binary mode; no EOF check
	PortDCB.fParity = FALSE;               // disable parity checking
	PortDCB.fOutxCtsFlow = FALSE;         // No CTS output flow control
	PortDCB.fOutxDsrFlow = FALSE;         // No DSR output flow control
	PortDCB.fDtrControl = FALSE;          // no flow control
	PortDCB.fDsrSensitivity = FALSE;      // DSR sensitivity
	PortDCB.fTXContinueOnXoff = FALSE;     //no xoff/xon.
	PortDCB.fOutX = FALSE;                // No XON/XOFF out flow control
	PortDCB.fInX = FALSE;                 // No XON/XOFF in flow control
	PortDCB.fErrorChar = FALSE;           // Disable error replacement
	PortDCB.fNull = FALSE;                // Disable null stripping
	PortDCB.fRtsControl = FALSE; //RTS_CONTROL_ENABLE; // RTS flow control
	PortDCB.fAbortOnError = FALSE;        // Do not abort reads/writes on error
	PortDCB.ByteSize = 8;                 // Number of bits/byte, 4-8
	PortDCB.Parity = NOPARITY;            // 0-4=no,odd,even,mark,space
	PortDCB.StopBits = ONESTOPBIT;        // 0,1,2 = 1, 1.5, 2
										  // Configure the port settings according to the new specifications
										  // of the DCB structure.
	if (!SetCommState(hComPort, &PortDCB)) {
		Sleep(1000);
		return false;
	}
	return true;
}

BOOL Plugin2AudioProcessor::setupComPort(char* port) {
	// START SERIAL PORT SETUP
	// Open Serial Port COMx: for Read and Write
	// For COM0..COM9 just use "COMX:" below. For COM10 and greater must use "\\\\.\\COMxx"
	TCHAR szPort[32];
	szPort[0] = _T('\0');
	_stprintf_s(szPort, _T("\\\\.\\%s"), port);

	hSerial = CreateFile(_T(szPort), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	// Check for file open errors
	if (hSerial == INVALID_HANDLE_VALUE) {
		errormsg += "file open errors\n";
		return false;
	}
	// Modify Com Port settings (i.e. Baud Rate, #bits, parity etc)
	if (!ModifyCommSettings(hSerial)) {
		errormsg += "com port settings errors";
		return false;
	}
	// END SERIAL SETUP
	errormsg = "successfully connected";
	return true;
}

void Plugin2AudioProcessor::scanPorts() //added function to find the present serial 
{
	bool gotPort = false; // in case the port is not found

	//Up to 255 COM ports are supported so we iterate through all of them seeing if we can get the default configuration
	for (UINT i = 1; i<256; i++)
	{
		//Form the Raw device name
		TCHAR szPort[32];
		szPort[0] = _T('\0');
		_stprintf_s(szPort, _T("COM%u"), i);

		COMMCONFIG cc;
		DWORD dwSize = sizeof(COMMCONFIG);
		if (GetDefaultCommConfig(szPort, &cc, &dwSize))
		{
			gotPort = true;
			portlist.add(szPort);
		}
	}
	if (!gotPort) {
		errormsg = "no active ports found";
	}
}

BOOL Plugin2AudioProcessor::sendSerialMsg(char dacLetter, uint8 value) {
	// make a c string for the chars because can't convert to string otherwise
	char buffer[3];
	buffer[0] = dacLetter;
	buffer[1] = synth;
	buffer[2] = '\0';

	// pad string value with 0's if not a 3 digit num
	String temp = String(value);
	temp = (value < 100) ? ("0" + temp) : temp;
	temp = (value < 10)  ? ("0" + temp) : temp;
	
	// compile parts and prepare output buffer
	temp = String(buffer) + temp;
	temp.copyToUTF8(cBuffer_out, 6);
	cBytes_out = 5;
	
	// record data on error message
	errormsg += " buff_out: " + String(cBuffer_out); //+ " buff_len: " + String(String(cBuffer_out).length());

	// writes out, updates error message, returns if write was \successful
	if (!WriteFile(hSerial, cBuffer_out, cBytes_out, &cBytes_out, NULL)) { 
		errormsg = "WRITE ERR-buff_out: " + String(cBuffer_out) + " buff_len: " + String(String(cBuffer_out).length());
		return false;
	}
	return true;
}



//==============================================================================
Plugin2AudioProcessor::Plugin2AudioProcessor()
{
	scanPorts();
	//setupComPort(selectedPort);
}

Plugin2AudioProcessor::~Plugin2AudioProcessor()
{
	CloseHandle(hSerial);
}

//==============================================================================
const String Plugin2AudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool Plugin2AudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool Plugin2AudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool Plugin2AudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double Plugin2AudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int Plugin2AudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int Plugin2AudioProcessor::getCurrentProgram()
{
    return 0;
}

void Plugin2AudioProcessor::setCurrentProgram (int index)
{
}

const String Plugin2AudioProcessor::getProgramName (int index)
{
    return String();
}

void Plugin2AudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void Plugin2AudioProcessor::prepareToPlay (double theSampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void Plugin2AudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void Plugin2AudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
	//MidiBuffer processedMidi; // for modifying midi data before it goes out to a synth
	int time;
	MidiMessage m;

	for (MidiBuffer::Iterator i(midiMessages); i.getNextEvent(m, time);)
	{
		if (m.isNoteOn())
		{
			sendSerialMsg('g', 255);
		}
		else if (m.isNoteOff()) // when off set it to 0
		{
			sendSerialMsg('g', 0);
		}
		
		incomingChannelNum = m.getNoteNumber();
		incomingChannelNum = (incomingChannelNum > 36) ? 36 : incomingChannelNum;

		double voltage = 1.0 / 12.0 * incomingChannelNum;//incomingChannelNum / 36 * 3.0;  //0 to 36 map linearly to 0 to 3v
		int dacValue = roundDoubleToInt(voltage / 3.3 * 255);
		// add internal synth calibration here later
		sendSerialMsg('a', dacValue);


		//else if (m.isAftertouch()){} // extras for aftertouch and pitchwheel if needed 
		//else if (m.isPitchWheel()){}
		//processedMidi.addEvent(m, time);
	}
	//midiMessages.swapWith(processedMidi);

 //	  const int totalNumInputChannels  = getTotalNumInputChannels();
 //   const int totalNumOutputChannels = getTotalNumOutputChannels();
 //
 //   // In case we have more outputs than inputs, this code clears any output
 //   // channels that didn't contain input data, (because these aren't
 //   // guaranteed to be empty - they may contain garbage).
 //   // This is here to avoid people getting screaming feedback
 //   // when they first compile a plugin, but obviously you don't need to keep
 //   // this code if your algorithm always overwrites all the output channels.
 //   for (int i = totalNumInputChannels; i < totalNumOutputChannels; ++i)
 //       buffer.clear (i, 0, buffer.getNumSamples());

 //   // This is the place where you'd normally do the guts of your plugin's
 //   // audio processing...
 //   for (int channel = 0; channel < totalNumInputChannels; ++channel)
 //   {
 //       float* channelData = buffer.getWritePointer (channel);
 //       // ..do something to the data...
 //   }
}

//==============================================================================
bool Plugin2AudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* Plugin2AudioProcessor::createEditor()
{
    return new Plugin2AudioProcessorEditor (*this);
}

//==============================================================================
void Plugin2AudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void Plugin2AudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new Plugin2AudioProcessor();
}
